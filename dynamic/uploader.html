<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SellInSeconds - Product Uploader</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f4f4f4; }
    input, textarea, button {
      width: 100%; padding: 10px; margin-top: 10px;
      font-size: 16px; border: 1px solid #ccc; border-radius: 5px;
    }
    button { background-color: #28a745; color: white; font-weight: bold; }
    .success { color: green; font-weight: bold; margin-top: 10px; }
    .error { color: red; font-weight: bold; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>üì§ Add Product to SellInSeconds</h2>
  <form id="productForm">
    <label>Product ID</label>
    <input type="number" id="id" required />

    <label>Model Name</label>
    <input type="text" id="model" required />

    <label>Price (‚Çπ...)</label>
    <input type="text" id="price" required />

    <label>Description</label>
    <textarea id="description" rows="4" required></textarea>

    <button type="submit">Upload Product</button>
    <div id="status"></div>
  </form>

  <script>
  // **THE MOST ROBUST base64EncodeUnicode FUNCTION**
  function base64EncodeUnicode(str) {
    // Convert the string to a Uint8Array using UTF-8 encoding
    const utf8Bytes = new TextEncoder().encode(str);

    // Create a "binary string" from the Uint8Array.
    // Each byte in the Uint8Array becomes a character in the string,
    // ensuring all character codes are <= 255, which btoa requires.
    let binaryString = '';
    for (let i = 0; i < utf8Bytes.length; i++) {
      binaryString += String.fromCharCode(utf8Bytes[i]);
    }

    // Now, btoa can safely encode this binary string
    return btoa(binaryString);
  }

    // IMPORTANT: For production, NEVER embed tokens directly in client-side code.
    // This token is visible to anyone inspecting your page.
    // Use a backend server to handle GitHub API calls.
    const token = "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";
    const repo = "pathanthanveerahmed/sellinseconds";
    const path = "dynamic/data.json";
    const branch = "main";

    document.getElementById("productForm").addEventListener("submit", async function(e) {
      e.preventDefault();

      const id = parseInt(document.getElementById("id").value.trim());
      // Removed Ô£ø replacement as it's not standard and might interfere
      const model = document.getElementById("model").value.trim();
      let price = document.getElementById("price").value.trim();
      // Removed Ô£ø replacement
      const description = document.getElementById("description").value.trim();

      if (!price.startsWith("‚Çπ")) price = "‚Çπ" + price;

      const statusEl = document.getElementById("status");
      statusEl.textContent = "‚è≥ Updating GitHub...";

      const api = `https://api.github.com/repos/${repo}/contents/${path}`;

      try {
        // Fetch current content to get SHA
        const res = await fetch(api, {
          headers: { Authorization: `token ${token}` }
        });

        if (!res.ok) {
            // Handle cases where the file doesn't exist (e.g., first upload)
            if (res.status === 404) {
                console.log("File not found, creating new file.");
                // We'll proceed without a SHA for a new file
            } else {
                const errorText = await res.text();
                throw new Error(`GitHub API fetch error: ${res.status} - ${errorText}`);
            }
        }

        const json = await res.json();
        const sha = json.sha; // Will be undefined if file not found initially
        let content = '';
        if (json.content) {
            content = atob(json.content);
        } else {
            // Initialize with an empty images array if the file didn't exist or was empty
            content = JSON.stringify({ images: [] }, null, 2);
        }

        let data;
        try {
            data = JSON.parse(content);
            if (!data.images) {
                data.images = []; // Ensure images array exists
            }
        } catch (parseError) {
            console.warn("Failed to parse existing data.json, initializing with empty array.", parseError);
            data = { images: [] }; // Fallback to empty if parsing fails
        }

        const newEntry = {
          id,
          name: `${model} ‚Äì ${price}`,
          description
        };

        const index = data.images.findIndex(p => p.id === id);
        if (index >= 0) {
          data.images[index] = newEntry; // Update existing entry
        } else {
          data.images.push(newEntry); // Add new entry
        }

        const updatedContentString = JSON.stringify(data, null, 2);

        const updated = {
          message: `Auto-add ID ${id} ‚Äì ${model}`,
          content: base64EncodeUnicode(updatedContentString),
          branch: branch
        };

        // Add SHA only if it exists (for updates, not initial creation)
        if (sha) {
            updated.sha = sha;
        }

        const uploadRes = await fetch(api, {
          method: "PUT",
          headers: {
            Authorization: `token ${token}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(updated)
        });

        if (uploadRes.ok) {
          statusEl.textContent = "‚úÖ Product updated successfully!";
          document.getElementById("productForm").reset();
        } else {
            const errorBody = await uploadRes.json(); // Get more detailed error from GitHub
            statusEl.textContent = `‚ùå Upload failed. GitHub error: ${uploadRes.status} - ${errorBody.message || JSON.stringify(errorBody)}`;
            console.error("GitHub API response error:", errorBody);
        }
      } catch (err) {
        statusEl.textContent = "‚ùå Error: " + err.message;
        console.error("Caught error:", err);
      }
    });
  </script>
</body>
</html>